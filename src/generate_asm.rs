use std::fs::OpenOptions;
use std::io::Write;

use crate::*;

/* hello world:
section .text
            global _start
        section .data
            msg db 'Hello world!', 0xa
            len equ $ - msg 

        section .text
            _start:
                mov edx,len ;message length
                mov ecx,msg ;message to write
                mov ebx,1   ;file descriptor (stdout)
                mov eax,4   ;system call number (sys_write)
                int 0x80    ;call kernel


                mov ebx,0   ;process' exit code
                mov eax,1   ;system call number (sys_exit)
                int 0x80    ;call kernel - this interrupt won't return
*/

const ASM_EXIT: &str = "; --- exit
mov rax, 60       ; exit
mov rdi, 0        ; code 0
syscall           ";

pub fn generate_asm(instructions: &mut Vec<Instr>) {
    if std::path::Path::new("out.asm").is_file() {
        std::fs::remove_file("out.asm").unwrap();
    }

    let mut out_file = OpenOptions::new()
        .create(true)
        .write(true)
        .open("out.asm")
        .unwrap();

    write!(out_file,
        "; --- generated by bingbang
section .text
global _start
            
_start:
"
    ).unwrap();

    if !instructions.ends_with(&[Instr::Exit]) {
        instructions.push(Instr::Exit);
    }

    for instr in instructions.iter() {
        match instr {
            Instr::Exit => writeln!(out_file, "{ASM_EXIT}").unwrap(),
            _ => todo!()
        }
    }
}